<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dog Breed Classification</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            /* Dark theme faded pattern */
            background-color: #111827; /* bg-gray-900 */
            background-image: radial-gradient(#4b5563 1px, transparent 1px);
            background-size: 20px 20px;
        }
        /* Custom styles for file input */
        .file-input-button {
            cursor: pointer;
        }
    </style>
</head>
<body class="text-gray-200 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-2xl bg-gray-800/80 backdrop-blur-sm rounded-2xl shadow-2xl shadow-blue-500/10 p-6 md:p-8 text-center border border-gray-700">
        <h1 class="text-3xl md:text-4xl font-bold text-white mb-2">Canine Classifier üêæ</h1>
        <p class="text-gray-400 mb-6">Use your webcam or upload an image to identify dog-like animals.</p>

        <div class="flex justify-center border-b border-gray-600 mb-6">
            <button id="webcam-tab" class="px-4 py-2 text-lg font-medium text-white border-b-2 border-blue-500">Webcam</button>
            <button id="upload-tab" class="px-4 py-2 text-lg font-medium text-gray-400 border-b-2 border-transparent hover:text-white">Upload Image</button>
        </div>

        <div id="content-area">
            <div id="webcam-content">
                <div id="webcam-container" class="mt-6 rounded-lg overflow-hidden w-full aspect-video bg-gray-900 flex items-center justify-center">
                    <p id="webcam-placeholder" class="text-gray-500">Camera will appear here</p>
                </div>
                 <button id="start-button" type="button" class="mt-4 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-300">
                    Start Camera
                </button>
            </div>

            <div id="upload-content" class="hidden">
                <div id="image-preview-container" class="mt-6 rounded-lg overflow-hidden w-full aspect-video bg-gray-900 flex items-center justify-center">
                    <img id="image-preview" class="hidden max-h-full max-w-full" />
                    <p id="upload-placeholder" class="text-gray-500">Your uploaded image will appear here</p>
                </div>
                <label for="image-upload" class="file-input-button mt-4 inline-block bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-300">
                    Choose an Image
                </label>
                <input type="file" id="image-upload" class="hidden" accept="image/*" />
            </div>
        </div>
        
        <div id="loading-spinner" class="hidden my-4 flex justify-center">
            <div class="animate-spin rounded-full h-12 w-12 border-b-4 border-blue-500"></div>
        </div>
        
        <div id="label-container" class="mt-4 text-left space-y-3"></div>
    </div>
    
    <footer class="mt-8 text-center text-gray-500 text-sm">
        <p>Powered by TensorFlow.js</p>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.3.1/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@0.8/dist/teachablemachine-image.min.js"></script>

    <script type="text/javascript">
        // --- Model & UI Logic ---

        const URL = "./";
        let model, webcam, labelContainer, maxPredictions;
        let animationFrameId;

        // A global variable to hold our labels
        let classLabels;

        // --- DOM Elements ---
        const webcamTab = document.getElementById('webcam-tab');
        const uploadTab = document.getElementById('upload-tab');
        const webcamContent = document.getElementById('webcam-content');
        const uploadContent = document.getElementById('upload-content');
        
        const startButton = document.getElementById('start-button');
        const webcamContainer = document.getElementById('webcam-container');
        const webcamPlaceholder = document.getElementById('webcam-placeholder');
        
        const imageUpload = document.getElementById('image-upload');
        const imagePreview = document.getElementById('image-preview');
        const imagePreviewContainer = document.getElementById('image-preview-container');
        const uploadPlaceholder = document.getElementById('upload-placeholder');

        const loadingSpinner = document.getElementById('loading-spinner');
        labelContainer = document.getElementById("label-container");

        // --- Tab Switching Logic ---
        webcamTab.addEventListener('click', () => switchTab('webcam'));
        uploadTab.addEventListener('click', () => switchTab('upload'));

        function switchTab(tab) {
            if (tab === 'webcam') {
                webcamTab.classList.add('border-blue-500', 'text-white');
                webcamTab.classList.remove('border-transparent', 'text-gray-400');
                uploadTab.classList.add('border-transparent', 'text-gray-400');
                uploadTab.classList.remove('border-blue-500', 'text-white');
                
                webcamContent.classList.remove('hidden');
                uploadContent.classList.add('hidden');
                stopWebcam(); // Stop webcam if running
            } else { // 'upload'
                uploadTab.classList.add('border-blue-500', 'text-white');
                uploadTab.classList.remove('border-transparent', 'text-gray-400');
                webcamTab.classList.add('border-transparent', 'text-gray-400');
                webcamTab.classList.remove('border-blue-500', 'text-white');

                uploadContent.classList.remove('hidden');
                webcamContent.classList.add('hidden');
                stopWebcam(); // Stop webcam if running
            }
            // Clear previous predictions
            labelContainer.innerHTML = '';
        }

        // --- Model Initialization ---
        async function loadModel() {
            const modelURL = URL + "model.json";
            const metadataURL = URL + "metadata.json";
            try {
                // Load the model using the correct TensorFlow.js function
                model = await tf.loadGraphModel(modelURL);

                // Manually fetch and parse the metadata.json
                const metadataResponse = await fetch(metadataURL);
                const metadata = await metadataResponse.json();
                
                // This is the only line that has been changed
                classLabels = metadata.classes.map(c => c.label);
                
                maxPredictions = classLabels.length;

            } catch (error) {
                // Log the detailed error to the console
                console.error("Error loading model:", error);
                alert("Failed to load the classification model. Please ensure model.json and metadata.json are present.");
            }
        }
        // Load the model as soon as the page loads
        loadModel();

        // --- Webcam Logic ---
        startButton.addEventListener('click', initWebcam);

        async function initWebcam() {
            if (!model) {
                alert("Model is not loaded yet. Please wait.");
                return;
            }
            startButton.disabled = true;
            startButton.textContent = 'Starting...';
            loadingSpinner.classList.remove('hidden');
            webcamPlaceholder.classList.add('hidden');

            const flip = true;
            webcam = new tmImage.Webcam(400, 400, flip);
            try {
                await webcam.setup();
                await webcam.play();
                animationFrameId = window.requestAnimationFrame(loop);

                webcamContainer.innerHTML = '';
                webcamContainer.appendChild(webcam.canvas);
                startButton.classList.add('hidden');
            } catch (e) {
                console.error("Could not start webcam", e);
                webcamPlaceholder.textContent = "Could not access camera. Please check permissions.";
                webcamPlaceholder.classList.remove('hidden');
                startButton.disabled = false;
                startButton.textContent = 'Start Camera';
            } finally {
                loadingSpinner.classList.add('hidden');
            }
        }

        async function loop() {
            webcam.update();
            await predict(webcam.canvas);
            animationFrameId = window.requestAnimationFrame(loop);
        }
        
        function stopWebcam() {
            if (webcam && webcam.isPlaying) {
                webcam.stop();
            }
            if(animationFrameId) {
                window.cancelAnimationFrame(animationFrameId);
            }
            webcamContainer.innerHTML = '';
            webcamContainer.appendChild(webcamPlaceholder);
            webcamPlaceholder.textContent = "Camera will appear here";
            webcamPlaceholder.classList.remove('hidden');
            startButton.classList.remove('hidden');
            startButton.disabled = false;
            startButton.textContent = 'Start Camera';
        }

        // --- Image Upload Logic ---
        imageUpload.addEventListener('change', async (event) => {
            if (!model) {
                alert("Model is not loaded yet. Please wait.");
                return;
            }
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    imagePreview.src = e.target.result;
                    imagePreview.classList.remove('hidden');
                    uploadPlaceholder.classList.add('hidden');
                    
                    loadingSpinner.classList.remove('hidden');
                    labelContainer.innerHTML = ''; // Clear old results
                    
                    // Wait for image to be fully loaded in the DOM before prediction
                    imagePreview.onload = async () => {
                        await predict(imagePreview);
                        loadingSpinner.classList.add('hidden');
                    }
                };
                reader.readAsDataURL(file);
            }
        });

        // --- Shared Prediction Logic ---
        async function predict(imageElement) {
            // Pre-process the image into a tensor
            const tensor = tf.browser.fromPixels(imageElement)
                .resizeNearestNeighbor([224, 224]) // Resize to your model's expected input size
                .toFloat()
                .expandDims();

            // Predict and get the output tensor
            const predictionTensor = model.predict(tensor);
            // Get the prediction data as a normal JavaScript array
            const probabilities = await predictionTensor.data();

            // --- NEW LOGIC START ---

            // Find the index of the highest probability
            let maxProbability = 0;
            let maxIndex = 0;
            for (let i = 0; i < probabilities.length; i++) {
                if (probabilities[i] > maxProbability) {
                    maxProbability = probabilities[i];
                    maxIndex = i;
                }
            }

            // Get the top breed name and its accuracy
            const topBreed = classLabels[maxIndex];
            const topAccuracy = (maxProbability * 100).toFixed(2);

            // Clear the previous results from the label container
            labelContainer.innerHTML = '';

            // Create a new, styled element to display the top result
            const resultDiv = document.createElement("div");
            resultDiv.className = "text-center p-4 bg-gray-700 rounded-lg shadow-md";
            // Clean up the breed name (e.g., "Afghan_hound" becomes "Afghan hound")
            const formattedBreedName = topBreed.replace(/_/g, ' ');

            resultDiv.innerHTML = `
                <p class="text-xl font-medium text-gray-300">Top Match</p>
                <p class="text-3xl font-bold text-white mt-1 capitalize">${formattedBreedName}</p>
                <p class="text-lg font-semibold text-blue-400 mt-2">${topAccuracy}% Accuracy</p>
            `;
            labelContainer.appendChild(resultDiv);

            // --- NEW LOGIC END ---

            // Clean up memory by disposing of the tensors
            tensor.dispose();
            predictionTensor.dispose();
        }

    </script>
</body>
</html>
